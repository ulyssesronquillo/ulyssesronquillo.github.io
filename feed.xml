<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-12-28T05:35:09+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">uly.me</title><subtitle></subtitle><entry><title type="html">bash input options</title><link href="http://0.0.0.0:4000/linux/2023/12/27/bash-input-options.html" rel="alternate" type="text/html" title="bash input options" /><published>2023-12-27T00:00:00+00:00</published><updated>2023-12-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/27/bash-input-options</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/27/bash-input-options.html"><![CDATA[<p>Here are input options that you can use in Bash.</p>

<ol>
  <li>You can set variables within the script.</li>
  <li>You can pass the arguments via command line.</li>
  <li>You can prompt the user to input data.</li>
</ol>

<p>Or you create a script that will incorporate all three.</p>

<ol>
  <li>If you want to set the variables manually, just remove the comments in the script.</li>
  <li>If you want to pass arguments via command, use this format: ./script.sh project instance zone policy snapback.</li>
  <li>If you don’t pass any arguments, you will be prompted to input all 5 options.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># project="projectid"
# instance="hostname"
# zone="us-central1-c"
# policy="hourly"
# snapback=3

# Format (requires all 5 arguments): ./script.sh project host zone policy snapback
# If no arguments are provided or less than 5 arguments, you will be prompted to input options.

if [ -z "$project" ] || [ -z "$instance" ] || [ -z "$zone" ] || [ -z "$policy" ] || [ -z "$snapback" ]; then

    if  [ "$#" -eq 5 ]; then

        project=$1
        instance=$2
        zone=$3
        policy=$4
        snapback=$5

    else 

        read -p "projectId : " project
        read -p "instance  : " instance
        read -p "zone      : " zone
        read -p "policy    : " policy
        read -p "snapback  : " snapback

    fi

fi

echo $project $instance $zone $policy $snapback
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="bash" /><category term="input" /><category term="options" /><category term="arguments" /><category term="variables" /><summary type="html"><![CDATA[Here are input options that you can use in Bash.]]></summary></entry><entry><title type="html">Bash function within a function</title><link href="http://0.0.0.0:4000/linux/2023/12/24/bash-function-within-a-function.html" rel="alternate" type="text/html" title="Bash function within a function" /><published>2023-12-24T00:00:00+00:00</published><updated>2023-12-24T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/24/bash-function-within-a-function</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/24/bash-function-within-a-function.html"><![CDATA[<p>How to make a function call within a function in Bash.</p>

<p>In my previous <a href="/cloud/2023/12/20/gcp-restore-boot-disk.html">post</a>, I used several functions. We will call them in the main function below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function main() {

  checkLogin
  displayHeader
  getDisks
  getSnaps 

  read -p "Do you want to proceed with restore? Are you sure? " -n 1 -r
  echo    # (optional) move to a new line
  if [[ $REPLY =~ ^[Yy]$ ]]
  then
    stopServer
    detachDisks
    deleteDisks
    createDisks
    attachDisks
    setAutodelete
    startServer
  fi
}

main 
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="bash" /><category term="function" /><category term="call" /><category term="within" /><category term="function" /><summary type="html"><![CDATA[How to make a function call within a function in Bash.]]></summary></entry><entry><title type="html">Random words from array</title><link href="http://0.0.0.0:4000/linux/2023/12/24/random-words-from-array.html" rel="alternate" type="text/html" title="Random words from array" /><published>2023-12-24T00:00:00+00:00</published><updated>2023-12-24T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/24/random-words-from-array</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/24/random-words-from-array.html"><![CDATA[<p>Here’s how to to generate random words from an array in Bash using shuf.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FOOD=('Milk' 'Bread' 'Eggs' 'Sausage' 'Grits' 'Banana' 'Oatmeal')
shuf -e ${FOOD[@]}
Milk
Grits
Sausage
Oatmeal
Bread
Banana
Eggs
</code></pre></div></div>

<p>You can limit output to 3 by piping output using head -n 3.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FOOD=('Milk' 'Bread' 'Eggs' 'Sausage' 'Grits' 'Banana' 'Oatmeal')
shuf -e ${FOOD[@]} | head -n 3
Bread
Sausage
Eggs
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="random" /><category term="words" /><category term="array" /><category term="bash" /><category term="shuf" /><summary type="html"><![CDATA[Here’s how to to generate random words from an array in Bash using shuf.]]></summary></entry><entry><title type="html">Search replace lowercase</title><link href="http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase.html" rel="alternate" type="text/html" title="Search replace lowercase" /><published>2023-12-21T00:00:00+00:00</published><updated>2023-12-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase.html"><![CDATA[<p>Here’s a script I use to edit over 1000 files to convert my post titles to all lowercase.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash 
cd ~/Code/docker/ulyme/_posts
function searchReplace() {
    for filename in 20*.md; do
        sed -i -e 's/title:.*/\L&amp;/g' $filename
    done
}
searchReplace

</code></pre></div></div>

<p>It took a mere 2-3 seconds to convert all titles on over 1000 files.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="search" /><category term="replace" /><category term="lowercase" /><summary type="html"><![CDATA[Here’s a script I use to edit over 1000 files to convert my post titles to all lowercase.]]></summary></entry><entry><title type="html">gcp restore all disks</title><link href="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks.html" rel="alternate" type="text/html" title="gcp restore all disks" /><published>2023-12-20T00:00:00+00:00</published><updated>2023-12-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks.html"><![CDATA[<p>Here’s my latest script on how to restore all disks of a VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

read -p "projectId : " project
read -p "instance  : " instance
read -p "zone      : " zone
read -p "policy    : " policy
read -p "snapback  : " snapback

function checkLogin() {

    user=$(gcloud config list account --format "value(core.account)")
    user=$(echo $user | cut -d@ -f1)
    user=${user/./-}

    if [ -z "$user" ]; then
    echo "You're not logged in to Google SDK."
    exit
    fi

}

function displayHeader() {

    echo "######################################################"
    echo "Starting the restore process for $instance "
    echo "######################################################"

}

function getDisks() {

    disks=$(gcloud compute disks list \
      --filter="users:$instance" \
      --format="value(name)" \
      --project="$project")

    echo "Listing disks for $instance ... "

    for disk in $disks; do

        echo $disk
    
    done

}

function getSnaps() {

    echo "Listing snapshots to restore for $instance ... "

    for disk in $disks; do

        snap=$(gcloud compute snapshots list \
          --filter="sourceSnapshotSchedulePolicy~$policy AND sourceDisk~$disk" \
          --format="value(name)" \
          --project="$project" \
          --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

        echo "$disk: $snap" 

    done 

}

function stopServer() {

    echo "Stopping server ..."

    gcloud compute instances stop $instance \
      --zone="$zone" \
      --project="$project"

}

function detachDisks() {

    echo "Detaching disks ..."

    for disk in $disks; do

        gcloud compute instances detach-disk $instance \
          --disk="$disk" \
          --zone="$zone" \
          --project="$project"

    done 

}

function deleteDisks() {

    echo "Deleting disks ..."

    for disk in $disks; do

        gcloud compute disks delete $disk \
          --zone="$zone" \
          --project="$project"

    done

}

function createDisks() {

    echo "Creating disks ..."

    for disk in $disks; do

        snap=$(gcloud compute snapshots list \
          --filter="sourceDisk~$disk" \
          --format="value(name)" \
          --project="$project" \
          --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

        gcloud compute disks create $disk \
          --source-snapshot="$snap" \
          --zone="$zone" \
          --project="$project"

    done

}

function attachDisks() {

    echo "Attaching disks ..."

    count=1

    for disk in $disks; do

        if [ $count == 1 ]; then 
            gcloud compute instances attach-disk $instance \
              --disk="$disk" \
              --device-name="$disk" \
              --zone="$zone" \
              --project="$project" \
              --boot
        else 
            gcloud compute instances attach-disk $instance \
              --disk="$disk" \
              --device-name="$disk" \
              --zone="$zone" \
              --project="$project"
        fi

        count=$((count+1))

    done 

}

function setAutodelete() {

    echo "Setting autodelete on disks ..."

    for disk in $disks; do

        gcloud compute instances set-disk-auto-delete $instance \
          --auto-delete \
          --disk="$disk" \
          --zone="$zone" \
          --project="$project"

    done 

}

function startServer() {

    echo "Starting server ..."

    gcloud compute instances start $instance \
      --zone="$zone" \
      --project="$project"

}

checkLogin
displayHeader
getDisks
getSnaps 

read -p "Do you want to proceed with restore? Are you sure? " -n 1 -r
echo    # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    stopServer
    detachDisks
    deleteDisks
    createDisks
    attachDisks
    setAutodelete
    startServer
fi
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="compute" /><category term="restore" /><category term="all" /><category term="disks" /><summary type="html"><![CDATA[Here’s my latest script on how to restore all disks of a VM in GCP.]]></summary></entry><entry><title type="html">gcp restore boot disk</title><link href="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk.html" rel="alternate" type="text/html" title="gcp restore boot disk" /><published>2023-12-20T00:00:00+00:00</published><updated>2023-12-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk.html"><![CDATA[<p>Here’s my latest script to restore the boot disk of a VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

read -p "projectId : " project
read -p "instance  : " instance
read -p "zone      : " zone
read -p "policy    : " policy
read -p "snapback  : " snapback

function checkLogin() {

    user=$(gcloud config list account --format "value(core.account)")
    user=$(echo $user | cut -d@ -f1)
    user=${user/./-}

    if [ -z "$user" ]; then
    echo "You're not logged in to Google SDK."
    exit
    fi

}

function displayHeader() {

    echo "######################################################"
    echo "Starting the restore process for $instance "
    echo "######################################################"

}

function getDisks() {

    disks=$(gcloud compute instances describe $instance \
      --project="$project" \
      --zone="$zone" \
      --format="get(disks[0].source)")

    echo "Listing disks for $instance ... "

    disk=$(echo ${disks##*/})

    echo $disk

}

function getSnaps() {

    echo "Listing snapshots to restore for $instance ... "
 
    snap=$(gcloud compute snapshots list \
      --filter="sourceSnapshotSchedulePolicy~$policy AND sourceDisk~$disk" \
      --format="value(name)" \
      --project="$project" \
      --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

    echo "$disk: $snap" 

}

function stopServer() {

    echo "Stopping server ..."

    gcloud compute instances stop $instance \
      --zone="$zone" \
      --project="$project"

}

function detachDisks() {

    echo "Detaching disks ..."

    gcloud compute instances detach-disk $instance \
      --disk="$disk" \
      --zone="$zone" \
      --project="$project"

}

function deleteDisks() {

    echo "Deleting disks ..."

    gcloud compute disks delete $disk \
      --zone="$zone" \
      --project="$project"

}

function createDisks() {

    echo "Creating disks ..."

    snap=$(gcloud compute snapshots list \
      --filter="sourceDisk~$disk" \
      --format="value(name)" \
      --project="$project" \
      --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

    gcloud compute disks create $disk \
      --source-snapshot="$snap" \
      --zone="$zone" \
      --project="$project"

}

function attachDisks() {

    echo "Attaching disks ..."

    gcloud compute instances attach-disk $instance \
      --disk="$disk" \
      --device-name="$disk" \
      --zone="$zone" \
      --project="$project" \
      --boot

}

function setAutodelete() {

    echo "Setting autodelete on disks ..."

    gcloud compute instances set-disk-auto-delete $instance \
      --auto-delete \
      --disk="$disk" \
      --zone="$zone" \
      --project="$project"

}

function startServer() {

    echo "Starting server ..."

    gcloud compute instances start $instance \
      --zone="$zone" \
      --project="$project"

}

checkLogin
displayHeader
getDisks
getSnaps 

read -p "Do you want to proceed with restore? Are you sure? " -n 1 -r
echo    # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    stopServer
    detachDisks
    deleteDisks
    createDisks
    attachDisks
    setAutodelete
    startServer
fi
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="restore" /><category term="vm" /><category term="boot" /><category term="disk" /><summary type="html"><![CDATA[Here’s my latest script to restore the boot disk of a VM in GCP.]]></summary></entry><entry><title type="html">gcp vm list all snapshots</title><link href="http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots.html" rel="alternate" type="text/html" title="gcp vm list all snapshots" /><published>2023-12-19T00:00:00+00:00</published><updated>2023-12-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots.html"><![CDATA[<p>Here’s how to list all the snapshots for a particular VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

if [ "$#" -ne 3 ]
then
  echo "Usage: ./gcp-list-all-snapshots.sh project server policy"
  exit
fi

# Set the name of the snapshot schedule policy and the disk name to filter by
PROJECT=$1            # PROJECT="projectId"
SERVER=$2             # DISK_NAME="hostname"
POLICY=$3             # POLICY_NAME="hourly or daily"

disks=$(gcloud compute disks list --project $PROJECT --filter="name~$SERVER" --format="value(name)") 

for disk in $disks; do

  # List all snapshots created by the snapshot schedule policy
  gcloud compute snapshots list \
  --filter="sourceSnapshotSchedulePolicy ~ $POLICY AND sourceDisk~$disk$" \
  --format="table(sourceDisk.basename(),name,creationTimestamp,sourceSnapshotSchedulePolicy.basename())" \
  --sort-by "~creationTimestamp" \
  --project="$PROJECT"

done
</code></pre></div></div>

<p>The script requires three arguments: projectId, hostname and policy.</p>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="vm" /><category term="list" /><category term="snapshots" /><category term="policy" /><summary type="html"><![CDATA[Here’s how to list all the snapshots for a particular VM in GCP.]]></summary></entry><entry><title type="html">jekyll new post script</title><link href="http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script.html" rel="alternate" type="text/html" title="jekyll new post script" /><published>2023-12-19T00:00:00+00:00</published><updated>2023-12-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script.html"><![CDATA[<p>Here’s my bash script that creates a new Jekyll post template. Once created, use vi to edit the post.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
if [ "$#" -ne 1 ]
then
  echo "Missing argument. Usage: ./jekyllNewPost.sh new-post-title"
  exit
fi

cd ~/Code/docker/ulyme/_posts/
ts=$(date +%Y-%m-%d)

title=$1
filename=($ts-$title.md)

pretitle=$(echo "${title^}")
posttitle=$(echo $pretitle | tr "-" " ")

cat &lt;&lt; EOF &gt; $filename
---
layout: post
author: ulysses
title: '$posttitle'
categories: 
tags: 
---
EOF

echo "vi ~/Code/docker/ulyme/_posts/$filename"
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="jekyll" /><category term="new" /><category term="post" /><category term="script" /><summary type="html"><![CDATA[Here’s my bash script that creates a new Jekyll post template. Once created, use vi to edit the post.]]></summary></entry><entry><title type="html">strip new lines on variables</title><link href="http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables.html" rel="alternate" type="text/html" title="strip new lines on variables" /><published>2023-12-18T00:00:00+00:00</published><updated>2023-12-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables.html"><![CDATA[<p>I had problems echoing four variables into one line. There seem to be some carriage return or new line somewhere that’s not visible.</p>

<p>So, here’s a line of code that will strip any new line or carriage return in the variable, and then use printf to display the variables on one line.</p>

<p>Strip the new lines.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>efs="${efs//$'\n'/ }"
name="${name//$'\n'/}"
total="${total//$'\n'/ }"
mesg="${mesg//$'\n'/}"
</code></pre></div></div>

<p>Now print them using printf on one line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf "%-30s %-40s %-20s %-30s\n" "$efs" "$new" "$total" "$mesg"
</code></pre></div></div>

<p>With that code, I’m now able to format my report nicely without the extra new lines.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="strip" /><category term="new lines" /><category term="variables" /><category term="bash" /><category term="echo" /><summary type="html"><![CDATA[I had problems echoing four variables into one line. There seem to be some carriage return or new line somewhere that’s not visible.]]></summary></entry><entry><title type="html">multiple github accounts</title><link href="http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts.html" rel="alternate" type="text/html" title="multiple github accounts" /><published>2023-12-17T00:00:00+00:00</published><updated>2023-12-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts.html"><![CDATA[<p>I have two Github accounts. The first one was cloned using HTTPS. When it was time to add a second one, I really didn’t want to mess around with multiple Github accounts and dealing with multiple credentials. I’ve decided to just clone the second account using SSH. I decided to do this mainly to simplify setup and to avoid the headaches with setting up multiple accounts in the config.</p>

<ul>
  <li>First repo - was cloned using HTTPS</li>
  <li>Second repo - was cloned using SSH</li>
</ul>

<p>The first repo which uses HTTPS requires a github key which will need to be generated on Github. The first time a repo is cloned, you’ll be prompted to supply the key. This key is kept in the <strong>~/.git-credentials</strong> file on the local desktop. The second repo which uses SSH requires a ssh key to be generated locally on your desktop, which you will then need to upload to github to allow authentication.</p>

<p>So here we go. Two separate ways of cloning repos without stepping on each other.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="github" /><category term="multiple" /><category term="accounts" /><summary type="html"><![CDATA[I have two Github accounts. The first one was cloned using HTTPS. When it was time to add a second one, I really didn’t want to mess around with multiple Github accounts and dealing with multiple credentials. I’ve decided to just clone the second account using SSH. I decided to do this mainly to simplify setup and to avoid the headaches with setting up multiple accounts in the config.]]></summary></entry></feed>