<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-12-22T12:58:05+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">uly.me</title><subtitle></subtitle><entry><title type="html">Search replace lowercase</title><link href="http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase.html" rel="alternate" type="text/html" title="Search replace lowercase" /><published>2023-12-21T00:00:00+00:00</published><updated>2023-12-21T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/21/search-replace-lowercase.html"><![CDATA[<p>Here’s a script I use to edit over 1000 files to convert my post titles to all lowercase.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash 
cd ~/Code/docker/ulyme/_posts
function searchReplace() {
    for filename in 20*.md; do
        sed -i -e 's/title:.*/\L&amp;/g' $filename
    done
}
searchReplace

</code></pre></div></div>

<p>It took a mere 2-3 seconds to convert all titles on over 1000 files.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="search" /><category term="replace" /><category term="lowercase" /><summary type="html"><![CDATA[Here’s a script I use to edit over 1000 files to convert my post titles to all lowercase.]]></summary></entry><entry><title type="html">gcp restore all disks</title><link href="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks.html" rel="alternate" type="text/html" title="gcp restore all disks" /><published>2023-12-20T00:00:00+00:00</published><updated>2023-12-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-all-disks.html"><![CDATA[<p>Here’s my latest script on how to restore all disks of a VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

read -p "projectId : " project
read -p "instance  : " instance
read -p "zone      : " zone
read -p "policy    : " policy
read -p "snapback  : " snapback

function checkLogin() {

    user=$(gcloud config list account --format "value(core.account)")
    user=$(echo $user | cut -d@ -f1)
    user=${user/./-}

    if [ -z "$user" ]; then
    echo "You're not logged in to Google SDK."
    exit
    fi

}

function displayHeader() {

    echo "######################################################"
    echo "Starting the restore process for $instance "
    echo "######################################################"

}

function getDisks() {

    disks=$(gcloud compute disks list \
      --filter="users:$instance" \
      --format="value(name)" \
      --project="$project")

    echo "Listing disks for $instance ... "

    for disk in $disks; do

        echo $disk
    
    done

}

function getSnaps() {

    echo "Listing snapshots to restore for $instance ... "

    for disk in $disks; do

        snap=$(gcloud compute snapshots list \
          --filter="sourceSnapshotSchedulePolicy~$policy AND sourceDisk~$disk" \
          --format="value(name)" \
          --project="$project" \
          --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

        echo "$disk: $snap" 

    done 

}

function stopServer() {

    echo "Stopping server ..."

    gcloud compute instances stop $instance \
      --zone="$zone" \
      --project="$project"

}

function detachDisks() {

    echo "Detaching disks ..."

    for disk in $disks; do

        gcloud compute instances detach-disk $instance \
          --disk="$disk" \
          --zone="$zone" \
          --project="$project"

    done 

}

function deleteDisks() {

    echo "Deleting disks ..."

    for disk in $disks; do

        gcloud compute disks delete $disk \
          --zone="$zone" \
          --project="$project"

    done

}

function createDisks() {

    echo "Creating disks ..."

    for disk in $disks; do

        snap=$(gcloud compute snapshots list \
          --filter="sourceDisk~$disk" \
          --format="value(name)" \
          --project="$project" \
          --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

        gcloud compute disks create $disk \
          --source-snapshot="$snap" \
          --zone="$zone" \
          --project="$project"

    done

}

function attachDisks() {

    echo "Attaching disks ..."

    count=1

    for disk in $disks; do

        if [ $count == 1 ]; then 
            gcloud compute instances attach-disk $instance \
              --disk="$disk" \
              --device-name="$disk" \
              --zone="$zone" \
              --project="$project" \
              --boot
        else 
            gcloud compute instances attach-disk $instance \
              --disk="$disk" \
              --device-name="$disk" \
              --zone="$zone" \
              --project="$project"
        fi

        count=$count+1

    done 

}

function setAutodelete() {

    echo "Setting autodelete on disks ..."

    for disk in $disks; do

        gcloud compute instances set-disk-auto-delete $instance \
          --auto-delete \
          --disk="$disk" \
          --zone="$zone" \
          --project="$project"

    done 

}

function startServer() {

    echo "Starting server ..."

    gcloud compute instances start $instance \
      --zone="$zone" \
      --project="$project"

}

checkLogin
displayHeader
getDisks
getSnaps 

read -p "Do you want to proceed with restore? Are you sure? " -n 1 -r
echo    # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    stopServer
    detachDisks
    deleteDisks
    createDisks
    attachDisks
    setAutodelete
    startServer
fi
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="compute" /><category term="restore" /><category term="all" /><category term="disks" /><summary type="html"><![CDATA[Here’s my latest script on how to restore all disks of a VM in GCP.]]></summary></entry><entry><title type="html">gcp restore boot disk</title><link href="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk.html" rel="alternate" type="text/html" title="gcp restore boot disk" /><published>2023-12-20T00:00:00+00:00</published><updated>2023-12-20T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/20/gcp-restore-boot-disk.html"><![CDATA[<p>Here’s my latest script to restore the boot disk of a VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

read -p "projectId : " project
read -p "instance  : " instance
read -p "zone      : " zone
read -p "policy    : " policy
read -p "snapback  : " snapback

function checkLogin() {

    user=$(gcloud config list account --format "value(core.account)")
    user=$(echo $user | cut -d@ -f1)
    user=${user/./-}

    if [ -z "$user" ]; then
    echo "You're not logged in to Google SDK."
    exit
    fi

}

function displayHeader() {

    echo "######################################################"
    echo "Starting the restore process for $instance "
    echo "######################################################"

}

function getDisks() {

    disks=$(gcloud compute instances describe $instance \
      --project="$project" \
      --zone="$zone" \
      --format="get(disks[0].source)")

    echo "Listing disks for $instance ... "

    disk=$(echo ${disks##*/})

    echo $disk

}

function getSnaps() {

    echo "Listing snapshots to restore for $instance ... "
 
    snap=$(gcloud compute snapshots list \
      --filter="sourceSnapshotSchedulePolicy~$policy AND sourceDisk~$disk" \
      --format="value(name)" \
      --project="$project" \
      --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

    echo "$disk: $snap" 

}

function stopServer() {

    echo "Stopping server ..."

    gcloud compute instances stop $instance \
      --zone="$zone" \
      --project="$project"

}

function detachDisks() {

    echo "Detaching disks ..."

    gcloud compute instances detach-disk $instance \
      --disk="$disk" \
      --zone="$zone" \
      --project="$project"

}

function deleteDisks() {

    echo "Deleting disks ..."

    gcloud compute disks delete $disk \
      --zone="$zone" \
      --project="$project"

}

function createDisks() {

    echo "Creating disks ..."

    snap=$(gcloud compute snapshots list \
      --filter="sourceDisk~$disk" \
      --format="value(name)" \
      --project="$project" \
      --sort-by="~creationTimestamp" | head -n $snapback | tail -n 1)

    gcloud compute disks create $disk \
      --source-snapshot="$snap" \
      --zone="$zone" \
      --project="$project"

}

function attachDisks() {

    echo "Attaching disks ..."

    gcloud compute instances attach-disk $instance \
      --disk="$disk" \
      --device-name="$disk" \
      --zone="$zone" \
      --project="$project" \
      --boot

}

function setAutodelete() {

    echo "Setting autodelete on disks ..."

    gcloud compute instances set-disk-auto-delete $instance \
      --auto-delete \
      --disk="$disk" \
      --zone="$zone" \
      --project="$project"

}

function startServer() {

    echo "Starting server ..."

    gcloud compute instances start $instance \
      --zone="$zone" \
      --project="$project"

}

checkLogin
displayHeader
getDisks
getSnaps 

read -p "Do you want to proceed with restore? Are you sure? " -n 1 -r
echo    # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    stopServer
    detachDisks
    deleteDisks
    createDisks
    attachDisks
    setAutodelete
    startServer
fi
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="restore" /><category term="vm" /><category term="boot" /><category term="disk" /><summary type="html"><![CDATA[Here’s my latest script to restore the boot disk of a VM in GCP.]]></summary></entry><entry><title type="html">gcp vm list all snapshots</title><link href="http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots.html" rel="alternate" type="text/html" title="gcp vm list all snapshots" /><published>2023-12-19T00:00:00+00:00</published><updated>2023-12-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2023/12/19/gcp-vm-list-all-snapshots.html"><![CDATA[<p>Here’s how to list all the snapshots for a particular VM in GCP.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

if [ "$#" -ne 3 ]
then
  echo "Usage: ./gcp-list-all-snapshots.sh project server policy"
  exit
fi

# Set the name of the snapshot schedule policy and the disk name to filter by
PROJECT=$1            # PROJECT="projectId"
SERVER=$2             # DISK_NAME="hostname"
POLICY=$3             # POLICY_NAME="hourly or daily"

disks=$(gcloud compute disks list --project $PROJECT --filter="name~$SERVER" --format="value(name)") 

for disk in $disks; do

  # List all snapshots created by the snapshot schedule policy
  gcloud compute snapshots list \
  --filter="sourceSnapshotSchedulePolicy ~ $POLICY AND sourceDisk~$disk$" \
  --format="table(sourceDisk.basename(),name,creationTimestamp,sourceSnapshotSchedulePolicy.basename())" \
  --sort-by "~creationTimestamp" \
  --project="$PROJECT"

done
</code></pre></div></div>

<p>The script requires three arguments: projectId, hostname and policy.</p>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="vm" /><category term="list" /><category term="snapshots" /><category term="policy" /><summary type="html"><![CDATA[Here’s how to list all the snapshots for a particular VM in GCP.]]></summary></entry><entry><title type="html">jekyll new post script</title><link href="http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script.html" rel="alternate" type="text/html" title="jekyll new post script" /><published>2023-12-19T00:00:00+00:00</published><updated>2023-12-19T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/19/jekyll-new-post-script.html"><![CDATA[<p>Here’s my bash script that creates a new Jekyll post template. Once created, use vi to edit the post.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
if [ "$#" -ne 1 ]
then
  echo "Missing argument. Usage: ./jekyllNewPost.sh new-post-title"
  exit
fi

cd ~/Code/docker/ulyme/_posts/
ts=$(date +%Y-%m-%d)

title=$1
filename=($ts-$title.md)

pretitle=$(echo "${title^}")
posttitle=$(echo $pretitle | tr "-" " ")

cat &lt;&lt; EOF &gt; $filename
---
layout: post
author: ulysses
title: '$posttitle'
categories: 
tags: 
---
EOF

echo "vi ~/Code/docker/ulyme/_posts/$filename"
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="jekyll" /><category term="new" /><category term="post" /><category term="script" /><summary type="html"><![CDATA[Here’s my bash script that creates a new Jekyll post template. Once created, use vi to edit the post.]]></summary></entry><entry><title type="html">strip new lines on variables</title><link href="http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables.html" rel="alternate" type="text/html" title="strip new lines on variables" /><published>2023-12-18T00:00:00+00:00</published><updated>2023-12-18T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/18/strip-new-lines-on-variables.html"><![CDATA[<p>I had problems echoing four variables into one line. There seem to be some carriage return or new line somewhere that’s not visible.</p>

<p>So, here’s a line of code that will strip any new line or carriage return in the variable, and then use printf to display the variables on one line.</p>

<p>Strip the new lines.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>efs="${efs//$'\n'/ }"
name="${name//$'\n'/}"
total="${total//$'\n'/ }"
mesg="${mesg//$'\n'/}"
</code></pre></div></div>

<p>Now print them using printf on one line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf "%-30s %-40s %-20s %-30s\n" "$efs" "$new" "$total" "$mesg"
</code></pre></div></div>

<p>With that code, I’m now able to format my report nicely without the extra new lines.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="strip" /><category term="new lines" /><category term="variables" /><category term="bash" /><category term="echo" /><summary type="html"><![CDATA[I had problems echoing four variables into one line. There seem to be some carriage return or new line somewhere that’s not visible.]]></summary></entry><entry><title type="html">multiple github accounts</title><link href="http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts.html" rel="alternate" type="text/html" title="multiple github accounts" /><published>2023-12-17T00:00:00+00:00</published><updated>2023-12-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/17/multiple-github-accounts.html"><![CDATA[<p>I have two Github accounts. The first one was cloned using HTTPS. When it was time to add a second one, I really didn’t want to mess around with multiple Github accounts and dealing with multiple credentials. I’ve decided to just clone the second account using SSH. I decided to do this mainly to simplify setup and to avoid the headaches with setting up multiple accounts in the config.</p>

<ul>
  <li>First repo - was cloned using HTTPS</li>
  <li>Second repo - was cloned using SSH</li>
</ul>

<p>The first repo which uses HTTPS requires a github key which will need to be generated on Github. The first time a repo is cloned, you’ll be prompted to supply the key. This key is kept in the <strong>~/.git-credentials</strong> file on the local desktop. The second repo which uses SSH requires a ssh key to be generated locally on your desktop, which you will then need to upload to github to allow authentication.</p>

<p>So here we go. Two separate ways of cloning repos without stepping on each other.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="github" /><category term="multiple" /><category term="accounts" /><summary type="html"><![CDATA[I have two Github accounts. The first one was cloned using HTTPS. When it was time to add a second one, I really didn’t want to mess around with multiple Github accounts and dealing with multiple credentials. I’ve decided to just clone the second account using SSH. I decided to do this mainly to simplify setup and to avoid the headaches with setting up multiple accounts in the config.]]></summary></entry><entry><title type="html">using internal links</title><link href="http://0.0.0.0:4000/linux/2023/12/17/using-internal-links.html" rel="alternate" type="text/html" title="using internal links" /><published>2023-12-17T00:00:00+00:00</published><updated>2023-12-17T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/17/using-internal-links</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/17/using-internal-links.html"><![CDATA[<p>Here’s how to use internal links within Jekyll. Use this format.</p>

<p><strong>[Some Link]({% post_url 2010-07-21-name-of-post %})</strong></p>

<p>I had to convert code to HTML characters to render properly.</p>]]></content><author><name>ulysses</name></author><category term="Linux" /><category term="jekyll" /><category term="internal" /><category term="links" /><summary type="html"><![CDATA[Here’s how to use internal links within Jekyll. Use this format.]]></summary></entry><entry><title type="html">editing multiple files</title><link href="http://0.0.0.0:4000/linux/2023/12/16/editing-multiple-files.html" rel="alternate" type="text/html" title="editing multiple files" /><published>2023-12-16T00:00:00+00:00</published><updated>2023-12-16T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/16/editing-multiple-files</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/16/editing-multiple-files.html"><![CDATA[<p>Editing 1000+ files is not fun. Here’s a script that cycles through certain files in a directory and performs a search and replace.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
for filename in 20*.md; do
  sed -i -e 's/author: Ulysses/author: ulysses/g' $filename
done
</code></pre></div></div>

<p>In this particular script, it looks for files starting with 20 with an extension of .md.</p>

<p>The script uses the <strong>sed command</strong> to perform search and replace.</p>]]></content><author><name>ulysses</name></author><category term="Linux" /><category term="edit" /><category term="multiple" /><category term="files" /><category term="sed" /><summary type="html"><![CDATA[Editing 1000+ files is not fun. Here’s a script that cycles through certain files in a directory and performs a search and replace.]]></summary></entry><entry><title type="html">switching from wordpress to jekyll</title><link href="http://0.0.0.0:4000/wp/2023/12/16/switching-from-wordpress-to-jekyll.html" rel="alternate" type="text/html" title="switching from wordpress to jekyll" /><published>2023-12-16T00:00:00+00:00</published><updated>2023-12-16T00:00:00+00:00</updated><id>http://0.0.0.0:4000/wp/2023/12/16/switching-from-wordpress-to-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/wp/2023/12/16/switching-from-wordpress-to-jekyll.html"><![CDATA[<p>I recently migrated this blog from WordPress to Jekyll due to several reasons.</p>

<p>It came down to these three reasons:</p>

<ul>
  <li>Cost</li>
  <li>Speed</li>
  <li>Security</li>
</ul>

<ol>
  <li>Cost. Jekyll generates static websites, meaning it can be hosted freely at Github. No more hosted VM’s. That’s a savings of $120 per year.</li>
  <li>Speed. Since Jekyll pages are static HTML pages, websites loads much faster. There are no more PHP, extra plugins or databases that slow down pages.</li>
  <li>Security. Since Jekyll pages are static files, they do not need a LAMP stack. So no more OS, PHP, plugins or MySQL databases to securely maintain.</li>
</ol>

<p>It’s a win win. The migration was quick and easy, but not it’s not entirely a 100% bug-free. I had to tweak Jekyll templates here and there to get it to look the way I wanted it. There are a ton of articles out there that covers the Jeklly to WordPress migration. I’m not going to cover the migration process here step by step. To quickly summarize, you’ll need to install a Jekyll exporter plugin in WordPress to export your posts. You can then import your posts into Jekyll and tweak Jekyll the way you want it. That’s it in a nutshell.</p>

<p>By the way, I’m running Jekyll in a Docker. If you are interested, here are the <a href="/linux/2022/08/31/jekyll-on-docker-container.html">instructions</a> to run Jekyll in a Docker container.</p>]]></content><author><name>ulysses</name></author><category term="wp" /><category term="wordpress" /><category term="switching" /><category term="jekyll" /><summary type="html"><![CDATA[I recently migrated this blog from WordPress to Jekyll due to several reasons.]]></summary></entry></feed>