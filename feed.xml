<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2024-01-14T19:36:17+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">uly.me</title><subtitle></subtitle><entry><title type="html">gcloud vm alias ip</title><link href="http://0.0.0.0:4000/cloud/2024/01/13/gcloud-vm-alias-ip.html" rel="alternate" type="text/html" title="gcloud vm alias ip" /><published>2024-01-13T00:00:00+00:00</published><updated>2024-01-13T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2024/01/13/gcloud-vm-alias-ip</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2024/01/13/gcloud-vm-alias-ip.html"><![CDATA[<p>In my <a href="/cloud/2024/01/12/terraform-gcp-vm-alias-ip.html">previous post</a>, I’ve provisioned a vm with an alias ip using terraform. In this post, I will do the same but will use gcloud commands.</p>

<p>First, let’s reserve an internal ip address.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcloud compute addresses create host-alias-ip \
--addresses 10.10.10.10
--region us-central1 \
--subnet projects/projectid/regions/us-central1/subnetworks/subnet-us-central1 \
--project projectid
</code></pre></div></div>

<p>To allocate automatically, leave out –addresses.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcloud compute addresses create host-alias-ip \
--region us-central1 \
--subnet projects/projectid/regions/us-central1/subnetworks/subnet-us-central1 \
--project projectid
</code></pre></div></div>

<p>To check reservations, list all in the project.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcloud compute addresses list --project projectid
</code></pre></div></div>

<p>Attach an alias ip to a vm instance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcloud compute instances network-interfaces update hostname \
--aliases 10.10.10.10 \
--zone us-central1-c \
--project projectid
</code></pre></div></div>

<p>To detach leave aliases blank.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcloud compute instances network-interfaces update hostname \
--aliases "" \
--zone us-central1-c \
--project projectid
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcloud" /><category term="vm" /><category term="ip" /><category term="alias" /><summary type="html"><![CDATA[In my previous post, I’ve provisioned a vm with an alias ip using terraform. In this post, I will do the same but will use gcloud commands.]]></summary></entry><entry><title type="html">terraform gcp vm alias ip</title><link href="http://0.0.0.0:4000/cloud/2024/01/12/terraform-gcp-vm-alias-ip.html" rel="alternate" type="text/html" title="terraform gcp vm alias ip" /><published>2024-01-12T00:00:00+00:00</published><updated>2024-01-12T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2024/01/12/terraform-gcp-vm-alias-ip</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2024/01/12/terraform-gcp-vm-alias-ip.html"><![CDATA[<p>How to build a VM in GCP with a secondary alias IP. Assuming that you already have a compute and a local block in your Terraform file.</p>

<p>Go to the locals block and add the local variables you’ll need.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locals {
  project          = "projectId"
  hostname         = "yourhostname"
}
</code></pre></div></div>

<p>Reserve an internal ip address by adding the <strong>google_compute_address</strong> block to your Terraform file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource "google_compute_address" "alias-ip" {
  name = "${local.hostname}-alias-ip"
  region = "us-central1"
  address_type = "INTERNAL"
  subnetwork = local.subnetwork
}
</code></pre></div></div>

<p>Inside your existing compute instance block, add the <strong>alias_ip_range</strong> to the network interface block.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  network_interface {
    network    = local.network
    subnetwork = local.subnetwork
    alias_ip_range {
      ip_cidr_range = google_compute_address.alias-ip.address
    }    
  }
</code></pre></div></div>

<p>The script will reserve an internal ip address and attach it the vm as an alias ip.</p>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="gcp" /><category term="vm" /><category term="alias" /><category term="ip" /><summary type="html"><![CDATA[How to build a VM in GCP with a secondary alias IP. Assuming that you already have a compute and a local block in your Terraform file.]]></summary></entry><entry><title type="html">install xrdp</title><link href="http://0.0.0.0:4000/linux/2024/01/11/install-xrdp.html" rel="alternate" type="text/html" title="install xrdp" /><published>2024-01-11T00:00:00+00:00</published><updated>2024-01-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2024/01/11/install-xrdp</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2024/01/11/install-xrdp.html"><![CDATA[<p>xrdp is a package that allows another desktop to connect to another using the rdp desktop software.</p>

<p>Install xrdp on the target desktop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install xrdp
</code></pre></div></div>

<p>Add a second user since you can’t use the default user. Use -m to create a home directory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo useradd -m john
</code></pre></div></div>

<p>Give new user sudo access. This is optional, but is nice to have if running root commands.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -a -G sudo john
</code></pre></div></div>

<p>Set the user’s password.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo passwd john
</code></pre></div></div>

<p>You can now connect from a rdp client to your desktop using username john.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="install" /><category term="xrdp" /><category term="remote" /><category term="desktop" /><summary type="html"><![CDATA[xrdp is a package that allows another desktop to connect to another using the rdp desktop software.]]></summary></entry><entry><title type="html">jekyll target blank</title><link href="http://0.0.0.0:4000/linux/2024/01/11/jekyll-target-blank.html" rel="alternate" type="text/html" title="jekyll target blank" /><published>2024-01-11T00:00:00+00:00</published><updated>2024-01-11T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2024/01/11/jekyll-target-blank</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2024/01/11/jekyll-target-blank.html"><![CDATA[<p>I found a really nice gem that sets all external links to open to a new tab. It’s called jekyll-target-blank. To add, just run the following.</p>

<p>Edit Gemfile and add this line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'jekyll-target-blank'
</code></pre></div></div>

<p>Edit the _config.yml file and add this line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins:
  - jekyll-target-blank
</code></pre></div></div>

<p>Run bundle install.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bundle install
</code></pre></div></div>

<p>Because I’m running Jekyll in a docker container, I had to restart it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose stop
docker-compose up -d
</code></pre></div></div>

<p>Check your external links. They should open up to a new tab.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="jekyll" /><category term="link" /><category term="target" /><category term="blank" /><summary type="html"><![CDATA[I found a really nice gem that sets all external links to open to a new tab. It’s called jekyll-target-blank. To add, just run the following.]]></summary></entry><entry><title type="html">scp multiple files</title><link href="http://0.0.0.0:4000/linux/2024/01/09/scp-multiple-files.html" rel="alternate" type="text/html" title="scp multiple files" /><published>2024-01-09T00:00:00+00:00</published><updated>2024-01-09T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2024/01/09/scp-multiple-files</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2024/01/09/scp-multiple-files.html"><![CDATA[<p>scp is an excellent utility for copying files to and from a server without the need for running a ftp server or some sort of file transfer service on the server. scp uses your existing ssh access to copy files to and from a server. You will need permissions to the remote server otherwise scp copy will fail. Whether pulling down a file or pushing a file to a server, scp can be invoked from a client regardless of file direction. You can copy a single file or multiple files. The examples below demonstrate this.</p>

<p>scp copy a single file to a server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp file.ext username@server:/home/homedir/
</code></pre></div></div>

<p>scp copy multiple local files to a server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp file1.ext file2.ext file3.ext username@server:/home/homedir/
</code></pre></div></div>

<p>scp copy a single file from a server to the desktop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp username@server:/home/homedir/file.ext .
</code></pre></div></div>

<p>scp copy multiple files from a server to the desktop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp username@server:/home/homedir/*.{txt,doc} . 
</code></pre></div></div>

<p>Here’s a script that I wrote to upload multiple files to a server. It looks for text and php files in the current directory and then uploads them to the server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
# create temp file
temp="temp"
&gt;$temp
# loop through selected files in the current directory
for file in *.{txt,php}; do
    # put all files in one row
    echo -n "$file " &gt;&gt; $temp 
done
# add new line at the end
echo "" &gt;&gt; $temp
# assign the list to a variable called $files
files=$(cat $temp)
# scp the files to the cloudreporting server
scp $files username@server:/home/homedir
# delete temp file
rm -f $temp
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="scp" /><category term="multiple" /><category term="files" /><summary type="html"><![CDATA[scp is an excellent utility for copying files to and from a server without the need for running a ftp server or some sort of file transfer service on the server. scp uses your existing ssh access to copy files to and from a server. You will need permissions to the remote server otherwise scp copy will fail. Whether pulling down a file or pushing a file to a server, scp can be invoked from a client regardless of file direction. You can copy a single file or multiple files. The examples below demonstrate this.]]></summary></entry><entry><title type="html">terraform local variables</title><link href="http://0.0.0.0:4000/cloud/2024/01/08/terraform-local-variables.html" rel="alternate" type="text/html" title="terraform local variables" /><published>2024-01-08T00:00:00+00:00</published><updated>2024-01-08T00:00:00+00:00</updated><id>http://0.0.0.0:4000/cloud/2024/01/08/terraform-local-variables</id><content type="html" xml:base="http://0.0.0.0:4000/cloud/2024/01/08/terraform-local-variables.html"><![CDATA[<p>If you find yourself entering the same value multiple times in your Terraform script, you can save yourself some time by declaring local variables inside a locals block and reuse them throughout your script or module.</p>

<p>Here’s a locals block.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locals {
  project          = "your_project_id"
  hostname         = "your_hostname"
  machine_image    = "your_machine_image"
}
</code></pre></div></div>

<p>Once the local variables are declared, you can reuse them anywhere and as many times as you want in your Terraform script or module.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>provider "google" {
  project = local.project
}

data "google_compute_image" "boot-image" {
  family  = local.machine_image
  project = local.project
}

resource "google_compute_instance" "instance" {
  name         = local.hostname
  machine_type = local.machine_type
  ...
}
</code></pre></div></div>

<p>Local variables are helpful if you’re repeating the same values throughout your configuration. You can make a change in one place and it will apply to multiple locations. The only gotcha is to not overdo it, because it will make your code harder to read. Use it in moderation.</p>]]></content><author><name>ulysses</name></author><category term="cloud" /><category term="terraform" /><category term="local" /><category term="variables" /><summary type="html"><![CDATA[If you find yourself entering the same value multiple times in your Terraform script, you can save yourself some time by declaring local variables inside a locals block and reuse them throughout your script or module.]]></summary></entry><entry><title type="html">display elapse time</title><link href="http://0.0.0.0:4000/linux/2024/01/03/display-elapse-time.html" rel="alternate" type="text/html" title="display elapse time" /><published>2024-01-03T00:00:00+00:00</published><updated>2024-01-03T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2024/01/03/display-elapse-time</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2024/01/03/display-elapse-time.html"><![CDATA[<p>Here’s a simple Bash script that displays how long it takes for a script to run from beginning to end. This is perfect tool for long running scripts that run for hours, and where you need to know much time it took to run from beginning to end. This is ideal for a script that you’ll run unattended.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

log='elapse.log'
&gt;$log

start() {

    start=$(date)
    begin=$(date +%s)
    echo 'Start: '$start | tee -a $log

}

stop() {

    stop=$(date)
    end=$(date +%s)
    echo 'Stop: '$stop | tee -a $log
    elapse=$((end-begin))

}

show_time() {
    num=$elapse
    min=0
    hour=0
    day=0
    if((num&gt;59));then
        ((sec=num%60))
        ((num=num/60))
        if((num&gt;59));then
            ((min=num%60))
            ((num=num/60))
            if((num&gt;23));then
                ((hour=num%24))
                ((day=num/24))
            else
                ((hour=num))
            fi
        else
            ((min=num))
        fi
    else
        ((sec=num))
    fi
    echo "$day"d "$hour"h "$min"m "$sec"s | tee -a $log
}

script() {

    echo "running script now..." | tee -a $log
    sleep 10

}

start
script
stop
show_time
</code></pre></div></div>

<p>In the example above, I’m running a script that echoes text and sleeps for 10s. Here’s the output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Start: Wed Jan 3 13:16:44 EST 2024
running script now...
Stop: Wed Jan 3 13:16:54 EST 2024
0d 0h 0m 10s
</code></pre></div></div>

<p>The result says it ran for 10s. You can also view the elapse.log file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat elapse.log
Start: Wed Jan 3 13:16:44 EST 2024
running script now...
Stop: Wed Jan 3 13:16:54 EST 2024
0d 0h 0m 10s
</code></pre></div></div>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="elapse" /><category term="time" /><category term="bash" /><category term="script" /><summary type="html"><![CDATA[Here’s a simple Bash script that displays how long it takes for a script to run from beginning to end. This is perfect tool for long running scripts that run for hours, and where you need to know much time it took to run from beginning to end. This is ideal for a script that you’ll run unattended.]]></summary></entry><entry><title type="html">truncate titles in jekyll</title><link href="http://0.0.0.0:4000/2024/01/01/truncate-titles-in-jekyll.html" rel="alternate" type="text/html" title="truncate titles in jekyll" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/2024/01/01/truncate-titles-in-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/2024/01/01/truncate-titles-in-jekyll.html"><![CDATA[<p>I switched to a slightly different format in the home page to display the date first followed by the post titles. In addition to the format change, I wanted to truncate the titles that are longer than 40 characters to display only the first 40 characters followed by 3 dots or “…” at the end. The key to making this possible was to use Jekyll’s advanced <a href="https://gist.github.com/JJediny/a466eed62cee30ad45e2">filters</a>, and in particular, using the truncate filter. Swapping the order of date and post titles was the easy part, but the key was using the truncate filter.</p>

<p>Here’s the code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>post.title | downcase | truncate: 40, ' ...'
</code></pre></div></div>

<p>The downcase filter converts post.title to lowercase.</p>

<p>The truncate filter truncates post.title longer than 40 characters and adds 3 dots at the end.</p>

<p>Truncate requires 2 parameters: the length of the string and the characters to append to the string.</p>]]></content><author><name>ulysses</name></author><summary type="html"><![CDATA[I switched to a slightly different format in the home page to display the date first followed by the post titles. In addition to the format change, I wanted to truncate the titles that are longer than 40 characters to display only the first 40 characters followed by 3 dots or “…” at the end. The key to making this possible was to use Jekyll’s advanced filters, and in particular, using the truncate filter. Swapping the order of date and post titles was the easy part, but the key was using the truncate filter.]]></summary></entry><entry><title type="html">format new volume</title><link href="http://0.0.0.0:4000/2023/12/31/format-new-volume.html" rel="alternate" type="text/html" title="format new volume" /><published>2023-12-31T00:00:00+00:00</published><updated>2023-12-31T00:00:00+00:00</updated><id>http://0.0.0.0:4000/2023/12/31/format-new-volume</id><content type="html" xml:base="http://0.0.0.0:4000/2023/12/31/format-new-volume.html"><![CDATA[<p>I recently bought a 2TB NVME SSD drive which I plan to install on my Linux Mint desktop. I have been taking a ton of pictures lately with my old Nikon D700 DSLR camera and I can use the extra space. Since the new drive is unformatted, here were the steps that I took to get it working on my desktop. This how-to assumes that I have installed the new NVME drive on your motherboard successfully.</p>

<p>The first thing to do is to find out the device name. It shows up as a 1.8TB disk on my desktop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsblk
nvme0n1 259:0    0   1.8T  0 disk
</code></pre></div></div>

<p>Check if it’s formatted. It should be empty. If not, it will display the file system type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo file -s /dev/nvme0n1 
</code></pre></div></div>

<p>If empty.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/nvme0n1: data
</code></pre></div></div>

<p>If formatted with XFS.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/nvme0n1: SGI XFS filesystem data (blksz 4096, inosz 512, v2 dirs)
</code></pre></div></div>

<p>Since it’s empty, let’s format the drive. I will use XFS as the file system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkfs -t xfs /dev/nvme0n1 
</code></pre></div></div>

<p>Let’s mount the drive after formatting. I will use the Nikon directory in my home directory as the mount volume.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir ~/Nikon
sudo mount /dev/nvme0n1 /home/ulysses/Nikon
</code></pre></div></div>

<p>Let’s unmount it temporarily.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo umount /home/ulysses/Nikon
</code></pre></div></div>

<p>Next, I will add an entry to the /etc/fstab to make the drive mount permanent after each reboot. Get the UUID of the new drive using the blkid command.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo blkid 
</code></pre></div></div>

<p>Now edit the /etc/fstab file to add the new volume entry.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/fstab
</code></pre></div></div>

<p>The entry will look similar to this. Enter the UUID by replacing the x’s.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /home/ulysses/Nikon          xfs        defaults            0 0
</code></pre></div></div>

<p>Test it by mounting all.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mount -a 
</code></pre></div></div>

<p>If there are no errors, mount was successful. You can check by running the df command.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df -Th
</code></pre></div></div>

<p>It should display something similar to below. I already have 5% data on the drive.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/nvme0n1        xfs        1.9T   83G  1.8T   5% /home/ulysses/Nikon
</code></pre></div></div>

<p>Since everything looks good, I can now safely reboot.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo shutdown -r 
</code></pre></div></div>]]></content><author><name>ulysses</name></author><summary type="html"><![CDATA[I recently bought a 2TB NVME SSD drive which I plan to install on my Linux Mint desktop. I have been taking a ton of pictures lately with my old Nikon D700 DSLR camera and I can use the extra space. Since the new drive is unformatted, here were the steps that I took to get it working on my desktop. This how-to assumes that I have installed the new NVME drive on your motherboard successfully.]]></summary></entry><entry><title type="html">how to shred a volume</title><link href="http://0.0.0.0:4000/linux/2023/12/29/how-to-shred-a-volume.html" rel="alternate" type="text/html" title="how to shred a volume" /><published>2023-12-29T00:00:00+00:00</published><updated>2023-12-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/linux/2023/12/29/how-to-shred-a-volume</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2023/12/29/how-to-shred-a-volume.html"><![CDATA[<p>If you have a disk drive, SSD or NVME storage device that need to be wiped clean, I recommend that you use the shred command.</p>

<p>In this example, I’m cleaning up the contents of my NVME device at /dev/nvme0n1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo shred -v -n 1 --random-source=/dev/urandom -z /dev/nvme0n1
</code></pre></div></div>

<p>I’m using these options and their explanation.</p>

<ul>
  <li>-v is verbose</li>
  <li>-n is the number of iterations. Mine is set to 1. You can increase it, but it can take hours.</li>
  <li>–random-source is set to /dev/urandom which is the kernel’s random number generator.</li>
  <li>-z means everything gets overwritten by zeros.</li>
</ul>

<p>Shred will make it nearly impossible to steal your data.</p>]]></content><author><name>ulysses</name></author><category term="linux" /><category term="shred" /><category term="volume" /><category term="wipe" /><category term="clean" /><category term="erase" /><summary type="html"><![CDATA[If you have a disk drive, SSD or NVME storage device that need to be wiped clean, I recommend that you use the shred command.]]></summary></entry></feed>